trigger:
- main

pool:
  vmImage: 'ubuntu-latest'

variables:
  containerRegistry: 'mytetragonregistry.azurecr.io'
  imageRepository: 'tetragon-demo-app'
  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile'
  tag: '$(Build.BuildId)'
  kubernetesNamespace: 'default'

stages:
- stage: Build
  displayName: 'Build and Security Scan'
  jobs:
  - job: Build
    displayName: 'Build and Security Analysis'
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '18.x'
      displayName: 'Install Node.js'

    - script: |
        echo "Installing dependencies..."
        npm install
        echo "Running application tests..."
        npm run test
      displayName: 'npm install and test'

    # Build and push Docker image
    - task: Docker@2
      displayName: 'Build and push container image'
      inputs:
        command: buildAndPush
        repository: $(imageRepository)
        dockerfile: $(dockerfilePath)
        containerRegistry: 'mytetragonregistry-connection'
        tags: |
          $(tag)
          latest

    # Container vulnerability scanning with Trivy
    - script: |
        echo "=========================================="
        echo "CONTAINER VULNERABILITY SCANNING (TRIVY)"
        echo "=========================================="
        
        # Install Trivy
        sudo apt-get update
        sudo apt-get install wget apt-transport-https gnupg lsb-release -y
        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
        echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
        sudo apt-get update
        sudo apt-get install trivy -y
        
        echo "Trivy version: $(trivy --version)"
        
        # Create results directory
        mkdir -p $(Build.ArtifactStagingDirectory)/security-results
        
        # Scan the built image for vulnerabilities
        echo "Scanning container image: $(containerRegistry)/$(imageRepository):$(tag)"
        trivy image --format json --output $(Build.ArtifactStagingDirectory)/security-results/trivy-results.json $(containerRegistry)/$(imageRepository):$(tag)
        trivy image --format table --output $(Build.ArtifactStagingDirectory)/security-results/trivy-report.txt $(containerRegistry)/$(imageRepository):$(tag)
        
        # Display critical and high vulnerabilities
        echo "=== VULNERABILITY SUMMARY ==="
        trivy image --severity HIGH,CRITICAL $(containerRegistry)/$(imageRepository):$(tag)
        
        echo "Trivy scan completed successfully!"
      displayName: 'Container Vulnerability Scan with Trivy'

    # Kubernetes manifest security scanning with Kubescape
    - script: |
        echo "=============================================="
        echo "KUBERNETES MANIFEST SECURITY SCAN (KUBESCAPE)"
        echo "=============================================="
        
        # Install Kubescape
        curl -s https://raw.githubusercontent.com/kubescape/kubescape/master/install.sh | /bin/bash
        
        # Add Kubescape to PATH
        export PATH=$PATH:/home/vsts/.kubescape/bin
        
        # Verify Kubescape installation
        kubescape version
        
        # Create results directory
        mkdir -p $(Build.ArtifactStagingDirectory)/security-results
        
        # Scan Kubernetes manifests
        echo "Scanning Kubernetes manifests..."
        kubescape scan k8s-manifests/ --format json --output $(Build.ArtifactStagingDirectory)/security-results/kubescape-results.json
        kubescape scan k8s-manifests/ --format pretty-printer --output $(Build.ArtifactStagingDirectory)/security-results/kubescape-report.txt
        
        # Scan security policies
        echo "Scanning Tetragon security policies..."
        kubescape scan security/ --format json --output $(Build.ArtifactStagingDirectory)/security-results/kubescape-policies.json
        
        echo "Kubescape scan completed successfully!"
      displayName: 'Kubernetes Security Scan with Kubescape'

    # Dockerfile security analysis
    - script: |
        echo "================================"
        echo "DOCKERFILE SECURITY ANALYSIS"
        echo "================================"
        
        # Install hadolint for Dockerfile linting
        wget https://github.com/hadolint/hadolint/releases/download/v2.12.0/hadolint-Linux-x86_64
        chmod +x hadolint-Linux-x86_64
        sudo mv hadolint-Linux-x86_64 /usr/local/bin/hadolint
        
        # Analyze Dockerfile
        echo "Analyzing Dockerfile security..."
        hadolint Dockerfile --format json > $(Build.ArtifactStagingDirectory)/security-results/dockerfile-analysis.json || true
        hadolint Dockerfile --format tty || true
        
        echo "Dockerfile analysis completed!"
      displayName: 'Dockerfile Security Analysis'

    # Publish security scan results
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Security Scan Results'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/security-results'
        artifactName: 'security-scan-results'

    # Publish test results (if you have test output)
    - task: PublishTestResults@2
      displayName: 'Publish Test Results'
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/test-results.xml'
        failTaskOnFailedTests: true
      condition: succeededOrFailed()

- stage: Deploy
  displayName: 'Deploy to AKS with Security Monitoring'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: Deploy
    displayName: 'Deploy Application and Security Policies'
    steps:
    
    # Pre-deployment validation
    - script: |
        echo "============================================="
        echo "PRE-DEPLOYMENT VALIDATION"
        echo "============================================="
        echo "Build ID: $(Build.BuildId)"
        echo "Container Image: $(containerRegistry)/$(imageRepository):$(tag)"
        echo "Target Namespace: $(kubernetesNamespace)"
        echo "Deployment Time: $(date)"
        echo "============================================="
      displayName: 'Pre-deployment Information'

    # Deploy the application
    - task: KubernetesManifest@0
      displayName: 'Deploy Application Manifests'
      inputs:
        action: deploy
        kubernetesServiceConnection: 'aks-connection'
        namespace: '$(kubernetesNamespace)'
        manifests: |
          k8s-manifests/deployment.yaml
          k8s-manifests/service.yaml

    # Apply Tetragon Security Policies (namespace-scoped for better security)
    - task: KubernetesManifest@0
      displayName: 'Apply Tetragon Security Policies'
      inputs:
        action: deploy
        kubernetesServiceConnection: 'aks-connection'
        namespace: '$(kubernetesNamespace)'
        manifests: |
          security/tetragon-namespace-policies.yaml
      continueOnError: true

    # Wait for deployment to be ready
    - task: Kubernetes@1
      displayName: 'Wait for Application Pods to be Ready'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: 'aks-connection'
        command: 'wait'
        arguments: '--for=condition=ready pod -l app=tetragon-demo-app --timeout=300s -n $(kubernetesNamespace)'

    # Verify application deployment
    - task: Kubernetes@1
      displayName: 'Verify Application Deployment'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: 'aks-connection'
        command: 'get'
        arguments: 'pods -l app=tetragon-demo-app -o wide -n $(kubernetesNamespace)'

    # Check service status and external IP
    - task: Kubernetes@1
      displayName: 'Check Service Status'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: 'aks-connection'
        command: 'get'
        arguments: 'service tetragon-demo-app-service -n $(kubernetesNamespace)'

    # Verify Tetragon security policies are applied
    - task: Kubernetes@1
      displayName: 'Verify Tetragon Security Policies'
      inputs:
        connectionType: 'Kubernetes Service Connection'
        kubernetesServiceEndpoint: 'aks-connection'
        command: 'get'
        arguments: 'tracingpoliciesnamespaced -n $(kubernetesNamespace)'
      continueOnError: true

    # FIXED: Test Tetragon functionality without requiring kube-system access
    - script: |
        echo "=========================================="
        echo "TETRAGON FUNCTIONALITY TEST"
        echo "=========================================="
        
        # Get pod name for testing
        POD_NAME=$(kubectl get pods -l app=tetragon-demo-app -n $(kubernetesNamespace) -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
        
        if [ -n "$POD_NAME" ]; then
            echo " Found application pod: $POD_NAME"
            
            # Test Tetragon status (this is the only kube-system access we need)
            echo "Checking Tetragon status..."
            if kubectl exec -n kube-system ds/tetragon -c tetragon -- tetra status 2>/dev/null; then
                echo "Tetragon is running and accessible"
                
                # Generate test security events
                echo "Generating test security events..."
                kubectl exec $POD_NAME -n $(kubernetesNamespace) -- echo "TETRAGON_PIPELINE_TEST_$(date +%s)" 2>/dev/null || echo " Event generation failed"
                kubectl exec $POD_NAME -n $(kubernetesNamespace) -- ls /etc/ 2>/dev/null || echo "File access test failed"
                kubectl exec $POD_NAME -n $(kubernetesNamespace) -- whoami 2>/dev/null || kubectl exec $POD_NAME -n $(kubernetesNamespace) -- id 2>/dev/null || echo "âš ï¸ User check failed"
                
                # Try to capture events (with timeout for CI/CD)
                echo "Testing event capture capability..."
                timeout 15s kubectl exec -n kube-system ds/tetragon -c tetragon -- tetra getevents -o compact --timeout 10s 2>/dev/null | head -10 || echo " Event capture test completed (may have timed out)"
                
                echo " Tetragon functionality test completed"
            else
                echo "Tetragon not accessible or not running"
                echo "This may be due to RBAC permissions or Tetragon installation"
            fi
        else
            echo " Could not find application pod"
        fi
        
        echo "Tetragon test finished!"
      displayName: 'Test Tetragon Security Monitoring'
      continueOnError: true

    # FIXED: Check Tetragon indirectly through policy verification
    - script: |
        echo "=========================================="
        echo "TETRAGON INFRASTRUCTURE VERIFICATION"
        echo "=========================================="
        
        # Check if our security policies exist (this proves Tetragon CRDs are available)
        echo "Verifying Tetragon CRDs and policies..."
        if kubectl get tracingpoliciesnamespaced -n $(kubernetesNamespace) 2>/dev/null; then
            echo " TracingPolicyNamespaced CRD is available"
            echo "Security policies are deployed"
            
            # Count policies
            POLICY_COUNT=$(kubectl get tracingpoliciesnamespaced -n $(kubernetesNamespace) --no-headers 2>/dev/null | wc -l)
            echo " Number of active security policies: $POLICY_COUNT"
            
            if [ "$POLICY_COUNT" -gt 0 ]; then
                echo "Security monitoring policies are active"
                
                # Show policy details
                echo "Active security policies:"
                kubectl get tracingpoliciesnamespaced -n $(kubernetesNamespace) -o custom-columns=NAME:.metadata.name,AGE:.metadata.creationTimestamp 2>/dev/null || echo "Policy details not accessible"
            else
                echo " No security policies found"
            fi
        else
            echo " TracingPolicyNamespaced CRD not found - Tetragon may not be installed"
        fi
        
        # Alternative: Check if we can access Tetragon via service
        echo ""
        echo "Testing Tetragon service accessibility..."
        if kubectl get service -n kube-system 2>/dev/null | grep -q tetragon; then
            echo " Tetragon service found in kube-system"
        else
            echo " Cannot verify Tetragon service (may be due to RBAC permissions)"
        fi
        
        echo "Infrastructure verification completed!"
      displayName: 'Verify Tetragon Infrastructure (RBAC-safe)'
      continueOnError: true

    # Application health check
    - script: |
        echo "=========================================="
        echo "APPLICATION HEALTH CHECK"
        echo "=========================================="
        
        # Get service external IP
        EXTERNAL_IP=$(kubectl get service tetragon-demo-app-service -n $(kubernetesNamespace) -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
        
        if [ -n "$EXTERNAL_IP" ] && [ "$EXTERNAL_IP" != "null" ] && [ "$EXTERNAL_IP" != "" ]; then
            echo " External IP found: $EXTERNAL_IP"
            echo "Testing application health..."
            
            # Wait for external IP to be ready
            echo "Waiting 30 seconds for LoadBalancer to be ready..."
            sleep 30
            
            # Test application endpoints
            echo "Testing root endpoint..."
            if curl -f http://$EXTERNAL_IP/ --max-time 10 --connect-timeout 5 2>/dev/null; then
                echo " Root endpoint is accessible"
            else
                echo " Root endpoint test failed (may still be starting)"
            fi
            
            echo "Testing health endpoint..."
            if curl -f http://$EXTERNAL_IP/health --max-time 10 --connect-timeout 5 2>/dev/null; then
                echo " Health endpoint is accessible"
            else
                echo " Health endpoint test failed (may not exist)"
            fi
            
            echo " Application URL: http://$EXTERNAL_IP"
            echo " Application is deployed and accessible"
        else
            echo " External IP not yet assigned"
            echo "Checking service configuration..."
            kubectl get service tetragon-demo-app-service -n $(kubernetesNamespace) -o wide 2>/dev/null || echo "Service details not accessible"
            
            # Check if it's a different service type
            SERVICE_TYPE=$(kubectl get service tetragon-demo-app-service -n $(kubernetesNamespace) -o jsonpath='{.spec.type}' 2>/dev/null)
            echo "Service type: $SERVICE_TYPE"
            
            if [ "$SERVICE_TYPE" = "ClusterIP" ]; then
                echo " Service is ClusterIP - no external IP expected"
            elif [ "$SERVICE_TYPE" = "NodePort" ]; then
                NODE_PORT=$(kubectl get service tetragon-demo-app-service -n $(kubernetesNamespace) -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null)
                echo "Service is NodePort - accessible on port $NODE_PORT"
            fi
        fi
        
        echo "Health check completed!"
      displayName: 'Application Health Check'
      continueOnError: true

    # Enhanced security posture summary
    - script: |
        echo "============================================="
        echo "SECURITY POSTURE SUMMARY"
        echo "============================================="
        echo " Container vulnerability scan: Completed with Trivy"
        echo " Kubernetes manifest scan: Completed with Kubescape"  
        echo " Dockerfile security analysis: Completed with Hadolint"
        echo " Runtime security monitoring: Deployed with Tetragon"
        echo " Security policies: Applied and monitoring"
        echo ""
        echo " DEPLOYMENT STATUS:"
        
        # Check deployment status
        if kubectl get deployment tetragon-demo-app -n $(kubernetesNamespace) 2>/dev/null; then
            READY_REPLICAS=$(kubectl get deployment tetragon-demo-app -n $(kubernetesNamespace) -o jsonpath='{.status.readyReplicas}' 2>/dev/null)
            DESIRED_REPLICAS=$(kubectl get deployment tetragon-demo-app -n $(kubernetesNamespace) -o jsonpath='{.spec.replicas}' 2>/dev/null)
            echo "   â€¢ Application pods: $READY_REPLICAS/$DESIRED_REPLICAS ready"
        fi
        
        # Check policy count
        POLICY_COUNT=$(kubectl get tracingpoliciesnamespaced -n $(kubernetesNamespace) --no-headers 2>/dev/null | wc -l)
        echo "   â€¢ Security policies active: $POLICY_COUNT"
        
        # Check service
        SERVICE_TYPE=$(kubectl get service tetragon-demo-app-service -n $(kubernetesNamespace) -o jsonpath='{.spec.type}' 2>/dev/null)
        echo "   â€¢ Service type: $SERVICE_TYPE"
        
        echo ""
        echo "ðŸ›¡ SECURITY MONITORING:"
        echo "   â€¢ Real-time process monitoring: Active"
        echo "   â€¢ File access monitoring: Active"  
        echo "   â€¢ Network connection monitoring: Active"
        echo ""
        echo " POST-DEPLOYMENT ACTIONS:"
        echo "   â€¢ Monitor events: kubectl exec -n kube-system ds/tetragon -c tetragon -- tetra getevents -o compact"
        echo "   â€¢ Filter app events: kubectl exec -n kube-system ds/tetragon -c tetragon -- tetra getevents -o compact --pods tetragon-demo-app"
        echo "   â€¢ Check policies: kubectl get tracingpoliciesnamespaced -n $(kubernetesNamespace)"
        echo "============================================="
        echo " DEPLOYMENT COMPLETED SUCCESSFULLY!"
        echo "============================================="
      displayName: 'Security Posture Summary'

    # Collect deployment information  
    - script: |
        echo "Collecting deployment information..."
        
        # Create deployment summary
        mkdir -p $(Build.ArtifactStagingDirectory)/deployment-info
        
        # Get deployment details (only what we have access to)
        kubectl get pods -l app=tetragon-demo-app -n $(kubernetesNamespace) -o yaml > $(Build.ArtifactStagingDirectory)/deployment-info/pods.yaml 2>/dev/null || echo "Could not export pods"
        kubectl get service tetragon-demo-app-service -n $(kubernetesNamespace) -o yaml > $(Build.ArtifactStagingDirectory)/deployment-info/service.yaml 2>/dev/null || echo "Could not export service"
        kubectl get tracingpoliciesnamespaced -n $(kubernetesNamespace) -o yaml > $(Build.ArtifactStagingDirectory)/deployment-info/security-policies.yaml 2>/dev/null || echo "Could not export policies"
        kubectl get deployment tetragon-demo-app -n $(kubernetesNamespace) -o yaml > $(Build.ArtifactStagingDirectory)/deployment-info/deployment.yaml 2>/dev/null || echo "Could not export deployment"
        
        # Create deployment summary file
        echo "Deployment Summary - $(date)" > $(Build.ArtifactStagingDirectory)/deployment-info/deployment-summary.txt
        echo "Build ID: $(Build.BuildId)" >> $(Build.ArtifactStagingDirectory)/deployment-info/deployment-summary.txt
        echo "Image: $(containerRegistry)/$(imageRepository):$(tag)" >> $(Build.ArtifactStagingDirectory)/deployment-info/deployment-summary.txt
        echo "Namespace: $(kubernetesNamespace)" >> $(Build.ArtifactStagingDirectory)/deployment-info/deployment-summary.txt
        
        # Get external IP if available
        EXTERNAL_IP=$(kubectl get service tetragon-demo-app-service -n $(kubernetesNamespace) -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
        echo "External IP: $EXTERNAL_IP" >> $(Build.ArtifactStagingDirectory)/deployment-info/deployment-summary.txt
        
        # Get policy count
        POLICY_COUNT=$(kubectl get tracingpoliciesnamespaced -n $(kubernetesNamespace) --no-headers 2>/dev/null | wc -l)
        echo "Active Security Policies: $POLICY_COUNT" >> $(Build.ArtifactStagingDirectory)/deployment-info/deployment-summary.txt
        
        echo "Deployment information collected!"
      displayName: 'Collect Deployment Information'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Deployment Information'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/deployment-info'
        artifactName: 'deployment-info'
